<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Xslt on rOpenSci - open tools for open science</title>
    <link>https://ropensci.org/tags/xslt/</link>
    <description>Recent content in Xslt on rOpenSci - open tools for open science</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 10 Jan 2017 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://ropensci.org/tags/xslt/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Using xml schema and xslt in R</title>
      <link>https://ropensci.org/blog/2017/01/10/xslt-release/</link>
      <pubDate>Tue, 10 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://ropensci.org/blog/2017/01/10/xslt-release/</guid>
      <description>
        
        

&lt;p&gt;This week an update for &lt;a href=&#34;https://cran.r-project.org/web/packages/xml2/index.html&#34;&gt;xml2&lt;/a&gt; and a new &lt;a href=&#34;https://cran.r-project.org/web/packages/xslt/index.html&#34;&gt;xslt&lt;/a&gt; package have appeared on CRAN. A full announcement for xml2 version 1.1 will appear on the &lt;a href=&#34;https://blog.rstudio.org/&#34;&gt;rstudio blog&lt;/a&gt;. This post explains xml &lt;em&gt;validation&lt;/em&gt; (via xsd schema) and xml &lt;em&gt;transformation&lt;/em&gt; (via xslt stylesheets) which have been added in this release.&lt;/p&gt;

&lt;p&gt;XML schemas and stylesheets are not exactly new; both &lt;a href=&#34;https://www.w3.org/TR/xslt11/&#34;&gt;xslt 1.1&lt;/a&gt; (2001) and &lt;a href=&#34;https://www.w3.org/TR/xmlschema-1/&#34;&gt;xsd 1.0&lt;/a&gt; (2004) have been available in browsers for over a decade. Revised specifications for xsd/xslt are still developed, but not widely implemented due to declined popularity of xml itself. Our R implementation builds on &lt;a href=&#34;http://xmlsoft.org/libxslt/&#34;&gt;libxslt&lt;/a&gt; which supports XSLT 1.0 features plus most of the EXSLT set of processor-portable extensions functions.&lt;/p&gt;

&lt;h2 id=&#34;xml-validation-with-xsd&#34;&gt;XML Validation with XSD&lt;/h2&gt;

&lt;p&gt;XML schema, also referred to as XSD (XML Schema Definition) is standard for defining the fields and formats that are supposed to appear within an XML document. This provides a formal method for validating XML messages. The schema itself is also written in XML (there is even an &lt;a href=&#34;https://www.w3.org/2001/XMLSchema.xsd&#34;&gt;xsd schema&lt;/a&gt; for validating xml schemas).&lt;/p&gt;

&lt;p&gt;This &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/ms256129(v=vs.110).aspx&#34;&gt;example&lt;/a&gt; from msdn illustrates the idea using a schema for a hypothetical purchase order. Imagine a vendor has an XML api for retailers to automatically order products. The order can be quite complex but the schema formally describes what constitutes a valid XML order message. It contains fields like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt; &amp;lt;xs:complexType name=&amp;quot;PurchaseOrderType&amp;quot;&amp;gt;
  &amp;lt;xs:sequence&amp;gt;
   &amp;lt;xs:element name=&amp;quot;shipTo&amp;quot; type=&amp;quot;USAddress&amp;quot;/&amp;gt;
   &amp;lt;xs:element name=&amp;quot;billTo&amp;quot; type=&amp;quot;USAddress&amp;quot;/&amp;gt;
   &amp;lt;xs:element ref=&amp;quot;comment&amp;quot; minOccurs=&amp;quot;0&amp;quot;/&amp;gt;
   &amp;lt;xs:element name=&amp;quot;items&amp;quot;  type=&amp;quot;Items&amp;quot;/&amp;gt;
  &amp;lt;/xs:sequence&amp;gt;
  &amp;lt;xs:attribute name=&amp;quot;orderDate&amp;quot; type=&amp;quot;xs:date&amp;quot;/&amp;gt;
 &amp;lt;/xs:complexType&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Both the client and server can easily validate an XML order against this schema to ensure that all required fields are present and contain the correct format. A copy of this example is included with the &lt;code&gt;xml2&lt;/code&gt; package:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Example order
doc &amp;lt;- read_xml(system.file(&amp;quot;extdata/order-doc.xml&amp;quot;, package = &amp;quot;xml2&amp;quot;))

# Example schema
schema &amp;lt;- read_xml(system.file(&amp;quot;extdata/order-schema.xml&amp;quot;, package = &amp;quot;xml2&amp;quot;))
xml_validate(doc, schema)
# TRUE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;xml_validate&lt;/code&gt; function returns TRUE or FALSE. If FALSE it also contains an attribute with a data frame listing invalid elements in the XML document. Let&amp;rsquo;s replace some text in the XML document to make it invalid:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Create invalid order to test
str &amp;lt;- readLines(system.file(&amp;quot;extdata/order-doc.xml&amp;quot;, package = &amp;quot;xml2&amp;quot;))
str &amp;lt;- sub(&amp;quot;&amp;lt;quantity&amp;gt;1&amp;quot;, &amp;quot;&amp;lt;quantity&amp;gt;&amp;quot;, str)
str &amp;lt;- sub(&amp;quot;95819&amp;quot;, &amp;quot;ABC95819&amp;quot;, str)
str &amp;lt;- sub(&#39;partNum=&amp;quot;926-AA&amp;quot;&#39;, &amp;quot;&amp;quot;, str)
doc &amp;lt;- read_xml(paste(str, collapse = &amp;quot;\n&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This new document will fail validation. The return object from &lt;code&gt;xml_validate&lt;/code&gt; contains an &lt;code&gt;error&lt;/code&gt; attribute with a dataframe containing the validation errors.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Fails validation
out &amp;lt;- xml_validate(doc, schema)

# Show the errors
attr(out, &amp;quot;errors&amp;quot;)
#[1] &amp;quot;Element &#39;zip&#39;: &#39;ABC95819&#39; is not a valid value of the atomic type &#39;xs:decimal&#39;.&amp;quot;
#[2] &amp;quot;Element &#39;quantity&#39;: &#39;&#39; is not a valid value of the local atomic type.&amp;quot;
#[3] &amp;quot;Element &#39;item&#39;: The attribute &#39;partNum&#39; is required but missing.&amp;quot;
#[4] &amp;quot;Element &#39;quantity&#39;: &#39;&#39; is not a valid value of the local atomic type.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When implementing an R client for a system with an XML API which also provides a schema, it is good practice to validate your messages before submitting them to the server. Thereby you catch problems with your XML document locally.&lt;/p&gt;

&lt;h2 id=&#34;xml-transformation-with-xsl&#34;&gt;XML Transformation with XSL&lt;/h2&gt;

&lt;p&gt;Extensible Stylesheet Language (XSL) Transformation provides a standardized language for converting a certain XML structure into another XML or HTML structure. Usually the original xml document provides the raw data, and the stylesheet contains a template for a HTML page that presents this content. Again, the XSLT document itself is also written in XML.&lt;/p&gt;

&lt;p&gt;We have decided to implement this in a separate package called &lt;code&gt;xslt&lt;/code&gt; because it requires another C library. Try the example from the &lt;code&gt;xml_xslt&lt;/code&gt; manual page:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(xslt)
doc &amp;lt;- read_xml(system.file(&amp;quot;examples/cd_catalog.xml&amp;quot;, package = &amp;quot;xslt&amp;quot;))
style &amp;lt;- read_xml(system.file(&amp;quot;examples/cd_catalog.xsl&amp;quot;, package = &amp;quot;xslt&amp;quot;))
html &amp;lt;- xml_xslt(doc, style)
cat(as.character(html))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This example is explained in more detail on &lt;a href=&#34;http://www.w3schools.com/xml/xsl_transformation.asp&#34;&gt;w3schools&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;why-use-xslt&#34;&gt;Why Use XSLT?&lt;/h2&gt;

&lt;p&gt;As the name implies, XSLT is designed to apply styling so that we can separate data of a document from its presentation markup. Take this &lt;a href=&#34;https://msdn.microsoft.com/nl-nl/library/ms765388(v=vs.85).aspx&#34;&gt;example&lt;/a&gt; of an XSLT document from the msdn homepage:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot;?&amp;gt;
&amp;lt;xsl:stylesheet xmlns:xsl=&amp;quot;http://www.w3.org/1999/XSL/Transform&amp;quot; version=&amp;quot;1.0&amp;quot;&amp;gt;
  &amp;lt;xsl:template match=&amp;quot;/hello-world&amp;quot;&amp;gt;
    &amp;lt;HTML&amp;gt;
      &amp;lt;HEAD&amp;gt;
        &amp;lt;TITLE&amp;gt;&amp;lt;/TITLE&amp;gt;
      &amp;lt;/HEAD&amp;gt;
      &amp;lt;BODY&amp;gt;
        &amp;lt;H1&amp;gt;
          &amp;lt;xsl:value-of select=&amp;quot;greeting&amp;quot;/&amp;gt;
        &amp;lt;/H1&amp;gt;
        &amp;lt;xsl:apply-templates select=&amp;quot;greeter&amp;quot;/&amp;gt;
      &amp;lt;/BODY&amp;gt;
    &amp;lt;/HTML&amp;gt;
  &amp;lt;/xsl:template&amp;gt;
  &amp;lt;xsl:template match=&amp;quot;greeter&amp;quot;&amp;gt;
    &amp;lt;DIV&amp;gt;from &amp;lt;I&amp;gt;&amp;lt;xsl:value-of select=&amp;quot;.&amp;quot;/&amp;gt;&amp;lt;/I&amp;gt;&amp;lt;/DIV&amp;gt;
  &amp;lt;/xsl:template&amp;gt;
&amp;lt;/xsl:stylesheet&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now if we apply this to a document like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot;?&amp;gt;
&amp;lt;?xml-stylesheet type=&amp;quot;text/xsl&amp;quot; href=&amp;quot;hello.xsl&amp;quot;?&amp;gt;
&amp;lt;hello-world&amp;gt;   &amp;lt;greeter&amp;gt;An XSLT Programmer&amp;lt;/greeter&amp;gt;   &amp;lt;greeting&amp;gt;Hello, World!&amp;lt;/greeting&amp;gt;&amp;lt;/hello-world&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We get the following output:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;HTML&amp;gt;
&amp;lt;HEAD&amp;gt;
&amp;lt;meta http-equiv=&amp;quot;Content-Type&amp;quot; content=&amp;quot;text/html; charset=UTF-8&amp;quot;&amp;gt;
&amp;lt;TITLE&amp;gt;&amp;lt;/TITLE&amp;gt;
&amp;lt;/HEAD&amp;gt;
&amp;lt;BODY&amp;gt;
&amp;lt;H1&amp;gt;Hello, World!&amp;lt;/H1&amp;gt;
&amp;lt;DIV&amp;gt;from &amp;lt;I&amp;gt;An XSLT Programmer&amp;lt;/I&amp;gt;
&amp;lt;/DIV&amp;gt;
&amp;lt;/BODY&amp;gt;
&amp;lt;/HTML&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When XSLT was introduced in &lt;a href=&#34;https://www.w3.org/TR/xslt&#34;&gt;1999&lt;/a&gt;, it was expected that xml would replace html. Computer scientists envisioned that dynamic content of websites would be served via semantically structured xmls feeds (such as RSS), and presentation markup (i.e. a nice html page) could be added on the client by applying a fixed transformation.&lt;/p&gt;

&lt;p&gt;Unfortunately that&amp;rsquo;s now how it went. It turned out that xslt was overly complex and never really found wide adoption. Instead people started writing dynamic HTML pages using PHP, which was slow and insecure, but considerably easier to learn. And that brings us back to R :)&lt;/p&gt;

      </description>
    </item>
    
  </channel>
</rss>
